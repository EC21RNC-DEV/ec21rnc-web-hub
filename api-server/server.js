const express = require("express");
const cors = require("cors");
const fs = require("fs");
const path = require("path");
const http = require("http");
const https = require("https");

const app = express();
const PORT = 3001;
const DATA_DIR = path.join(__dirname, "data");
const NGINX_CONF_DIR = path.join(__dirname, "dynamic-nginx");

const UPSTREAM_HOSTS = ["172.17.0.1", "203.242.139.254"];

// Middleware
app.use(cors());
app.use(express.json());

// --- Helpers ---

function ensureDataDir() {
  if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
}

function readJSON(filename, fallback) {
  const filepath = path.join(DATA_DIR, filename);
  try {
    if (!fs.existsSync(filepath)) return fallback;
    return JSON.parse(fs.readFileSync(filepath, "utf-8"));
  } catch {
    return fallback;
  }
}

function writeJSON(filename, data) {
  ensureDataDir();
  fs.writeFileSync(path.join(DATA_DIR, filename), JSON.stringify(data, null, 2));
}

// Simple hash (matches frontend simpleHash)
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash |= 0;
  }
  return `h_${hash.toString(36)}`;
}

// Init default admin password if not exists
function ensureAdmin() {
  const admin = readJSON("admin.json", null);
  if (!admin) {
    writeJSON("admin.json", { passwordHash: simpleHash("Itmaya2009!") });
  }
}

ensureDataDir();
ensureAdmin();

// --- Host Resolution ---

// Quick TCP connect test (no HTTP, just checks if port is open)
function testConnect(hostname, port, timeout = 2000) {
  return new Promise((resolve) => {
    const socket = require("net").createConnection({ host: hostname, port, timeout }, () => {
      socket.destroy();
      resolve(true);
    });
    socket.on("error", () => resolve(false));
    socket.on("timeout", () => { socket.destroy(); resolve(false); });
  });
}

// Try each upstream host, return the first one that responds
async function resolveHost(port) {
  for (const host of UPSTREAM_HOSTS) {
    if (await testConnect(host, port)) return host;
  }
  return UPSTREAM_HOSTS[0]; // default fallback
}

// --- Dynamic Nginx Config Generator ---

async function generateNginxConf() {
  if (!fs.existsSync(NGINX_CONF_DIR)) fs.mkdirSync(NGINX_CONF_DIR, { recursive: true });

  const services = readJSON("custom-services.json", []);
  const withPath = services.filter((s) => s.path && s.port);

  // Resolve hosts in parallel
  const hosts = await Promise.all(withPath.map((s) => resolveHost(s.port)));

  const blocks = withPath.map((s, i) => {
    const p = s.path.replace(/\/+$/, ""); // strip trailing slash
    const upstream = hosts[i];
    return `# Custom: ${s.name} â†’ ${upstream}:${s.port}
location ${p} {
    return 301 $scheme://$host${p}/;
}
location ${p}/ {
    proxy_pass http://${upstream}:${s.port}/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_set_header X-Forwarded-Prefix ${p};
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
    proxy_buffering off;
}`;
  });

  const conf = blocks.length > 0
    ? `# Auto-generated by admin API - DO NOT EDIT\n\n${blocks.join("\n\n")}\n`
    : "# No custom services with paths\n";

  fs.writeFileSync(path.join(NGINX_CONF_DIR, "custom-services.conf"), conf);
  // Signal nginx to reload
  fs.writeFileSync(path.join(NGINX_CONF_DIR, ".reload"), Date.now().toString());
  console.log(`[nginx] Generated config for ${blocks.length} custom service(s)`);
}

// Debug: show generated nginx config
app.get("/api/admin/nginx-conf", (_req, res) => {
  const confPath = path.join(NGINX_CONF_DIR, "custom-services.conf");
  try {
    const content = fs.readFileSync(confPath, "utf-8");
    res.type("text/plain").send(content);
  } catch {
    res.status(404).send("No config file");
  }
});

// Generate on startup
generateNginxConf();

// =====================
// Custom Services API
// =====================

app.get("/api/admin/services/custom", (_req, res) => {
  const services = readJSON("custom-services.json", []);
  res.json(services);
});

app.post("/api/admin/services/custom", async (req, res) => {
  const services = readJSON("custom-services.json", []);
  const { name, description, port, path: svcPath, defaultStatus, iconName, category } = req.body;

  if (!name || !port) {
    return res.status(400).json({ error: "name and port are required" });
  }

  const newService = {
    id: `custom-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
    name,
    description: description || "",
    port: Number(port),
    ...(svcPath ? { path: svcPath } : {}),
    defaultStatus: defaultStatus || "online",
    iconName: iconName || "Server",
    category: category || "tools",
    createdAt: new Date().toISOString(),
  };

  services.push(newService);
  writeJSON("custom-services.json", services);
  await generateNginxConf();
  res.status(201).json(newService);
});

app.put("/api/admin/services/custom/:id", async (req, res) => {
  const services = readJSON("custom-services.json", []);
  const idx = services.findIndex((s) => s.id === req.params.id);
  if (idx === -1) return res.status(404).json({ error: "service not found" });

  const { name, description, port, path: svcPath, defaultStatus, iconName, category } = req.body;
  if (name !== undefined) services[idx].name = name;
  if (description !== undefined) services[idx].description = description;
  if (port !== undefined) services[idx].port = Number(port);
  if (svcPath !== undefined) services[idx].path = svcPath || undefined;
  if (defaultStatus !== undefined) services[idx].defaultStatus = defaultStatus;
  if (iconName !== undefined) services[idx].iconName = iconName;
  if (category !== undefined) services[idx].category = category;

  writeJSON("custom-services.json", services);
  await generateNginxConf();
  res.json(services[idx]);
});

app.delete("/api/admin/services/custom/:id", async (req, res) => {
  let services = readJSON("custom-services.json", []);
  const before = services.length;
  services = services.filter((s) => s.id !== req.params.id);
  if (services.length === before) return res.status(404).json({ error: "service not found" });

  writeJSON("custom-services.json", services);
  await generateNginxConf();
  res.json({ ok: true });
});

// =====================
// Status Overrides API
// =====================

app.get("/api/admin/status", (_req, res) => {
  const overrides = readJSON("status-overrides.json", {});
  res.json(overrides);
});

app.put("/api/admin/status/:id", (req, res) => {
  const overrides = readJSON("status-overrides.json", {});
  const { status } = req.body;
  if (!status || !["online", "maintenance", "inactive"].includes(status)) {
    return res.status(400).json({ error: "status must be online, maintenance, or inactive" });
  }

  overrides[req.params.id] = status;
  writeJSON("status-overrides.json", overrides);
  res.json({ ok: true });
});

app.delete("/api/admin/status/:id", (req, res) => {
  const overrides = readJSON("status-overrides.json", {});
  delete overrides[req.params.id];
  writeJSON("status-overrides.json", overrides);
  res.json({ ok: true });
});

app.delete("/api/admin/status", (_req, res) => {
  writeJSON("status-overrides.json", {});
  res.json({ ok: true });
});

// =====================
// Admin Only API
// =====================

app.get("/api/admin/admin-only", (_req, res) => {
  const ids = readJSON("admin-only.json", []);
  res.json(ids);
});

app.put("/api/admin/admin-only/:id", (req, res) => {
  const ids = readJSON("admin-only.json", []);
  const id = req.params.id;
  const idx = ids.indexOf(id);
  if (idx === -1) {
    ids.push(id);
  } else {
    ids.splice(idx, 1);
  }
  writeJSON("admin-only.json", ids);
  res.json({ ok: true, ids });
});

// =====================
// Hidden Services API
// =====================

app.get("/api/admin/hidden", (_req, res) => {
  const ids = readJSON("hidden-services.json", []);
  res.json(ids);
});

app.put("/api/admin/hidden/:id", (req, res) => {
  const ids = readJSON("hidden-services.json", []);
  const id = req.params.id;
  const idx = ids.indexOf(id);
  if (idx === -1) {
    ids.push(id);
  } else {
    ids.splice(idx, 1);
  }
  writeJSON("hidden-services.json", ids);
  res.json({ ok: true, ids });
});

// =====================
// Admin Auth API
// =====================

app.post("/api/admin/auth/verify", (req, res) => {
  const { passwordHash } = req.body;
  if (!passwordHash) return res.status(400).json({ error: "passwordHash is required" });

  const admin = readJSON("admin.json", { passwordHash: simpleHash("Itmaya2009!") });
  const valid = passwordHash === admin.passwordHash;
  res.json({ valid });
});

app.put("/api/admin/auth/password", (req, res) => {
  const { currentHash, newHash } = req.body;
  if (!currentHash || !newHash) {
    return res.status(400).json({ error: "currentHash and newHash are required" });
  }

  const admin = readJSON("admin.json", { passwordHash: simpleHash("Itmaya2009!") });
  if (currentHash !== admin.passwordHash) {
    return res.status(403).json({ error: "current password is incorrect" });
  }

  admin.passwordHash = newHash;
  writeJSON("admin.json", admin);
  res.json({ ok: true });
});

// =====================
// Health Check Proxy
// =====================

// Try all upstream hosts in parallel, return true if any responds with 2xx/3xx
function probePort(port, timeout = 5000) {
  return Promise.all(
    UPSTREAM_HOSTS.map((hostname) =>
      new Promise((resolve) => {
        const req = http.request(
          { hostname, port, path: "/", method: "HEAD", timeout },
          (res) => {
            resolve(res.statusCode >= 200 && res.statusCode < 400);
            res.resume();
          }
        );
        req.on("error", () => resolve(false));
        req.on("timeout", () => { req.destroy(); resolve(false); });
        req.end();
      })
    )
  ).then((results) => results.some(Boolean));
}

// Fallback: check via nginx proxy for Docker-network-only services
function probeViaProxy(svcPath, timeout = 5000) {
  return new Promise((resolve) => {
    const req = https.request(
      {
        hostname: "proxy",
        port: 443,
        path: svcPath,
        method: "HEAD",
        timeout,
        headers: { Host: "ec21rnc-agent.com" },
        rejectUnauthorized: false,
      },
      (res) => {
        resolve(res.statusCode >= 200 && res.statusCode < 400);
        res.resume();
      }
    );
    req.on("error", () => resolve(false));
    req.on("timeout", () => { req.destroy(); resolve(false); });
    req.end();
  });
}

app.post("/api/admin/health-check", async (req, res) => {
  const { portInfos, ports } = req.body;
  const items = portInfos || (ports ? ports.map((p) => ({ port: p })) : null);
  if (!Array.isArray(items) || items.length === 0) {
    return res.status(400).json({ error: "portInfos or ports array required" });
  }

  const results = await Promise.all(
    items.map(async ({ port, path: svcPath }) => {
      let reachable = await probePort(Number(port));
      if (!reachable && svcPath) {
        reachable = await probeViaProxy(svcPath);
      }
      return { port: Number(port), reachable };
    })
  );

  res.json(results);
});

// Debug: test upstream with different Host headers
app.get("/api/admin/debug-proxy/:port", async (req, res) => {
  const port = Number(req.params.port);
  const results = [];
  for (const hostname of UPSTREAM_HOSTS) {
    const status = await new Promise((resolve) => {
      const r = http.request(
        { hostname, port, path: "/", method: "GET", timeout: 3000 },
        (resp) => { resolve({ hostname, status: resp.statusCode }); resp.resume(); }
      );
      r.on("error", (e) => resolve({ hostname, status: `error: ${e.message}` }));
      r.on("timeout", () => { r.destroy(); resolve({ hostname, status: "timeout" }); });
      r.end();
    });
    results.push(status);
  }
  res.json(results);
});

// Health check
app.get("/api/admin/health", (_req, res) => {
  res.json({ status: "ok", timestamp: new Date().toISOString() });
});

app.listen(PORT, "0.0.0.0", () => {
  console.log(`Admin API server running on port ${PORT}`);
});
